/*
 * Copyright (c) 2021-2023 HPMicro
 * SPDX-License-Identifier: BSD-3-Clause
 *
 */

#include "board.h"
#include "hpm_can_drv.h"
#include "hpm_clock_drv.h"
#include "hpm_dma_drv.h"
#include "hpm_femc_drv.h"
#include "hpm_gpio_drv.h"
#include "hpm_i2c_drv.h"
#include "hpm_pllctl_drv.h"
#include "hpm_pmp_drv.h"
#include "hpm_pwm_drv.h"
#include "hpm_sysctl_drv.h"
#include "hpm_uart_drv.h"
#include "pinmux.h"

#if defined(FLASH_XIP) && FLASH_XIP
__attribute__((section(".nor_cfg_option"))) const uint32_t option[4] = {0xfcf90001, 0x00020007, 0x0, 0x0};
#endif

#if defined(FLASH_UF2) && FLASH_UF2
ATTR_PLACE_AT(".uf2_signature")
const uint32_t uf2_signature = BOARD_UF2_SIGNATURE;
#endif

// 初始化控制台
void board_init_console(void)
{
#if !defined(CONFIG_NDEBUG_CONSOLE) || !CONFIG_NDEBUG_CONSOLE
#if BOARD_CONSOLE_TYPE == CONSOLE_TYPE_UART
    console_config_t cfg;

    /* uart needs to configure pin function before enabling clock, otherwise the level change of
    uart rx pin when configuring pin function will cause a wrong data to be received.
    And a uart rx dma request will be generated by default uart fifo dma trigger level. */
    init_uart_pins((UART_Type *)BOARD_CONSOLE_BASE);

    /* Configure the UART clock to 24MHz */
    clock_set_source_divider(BOARD_CONSOLE_CLK_NAME, clk_src_osc24m, 1U);
    clock_add_to_group(BOARD_CONSOLE_CLK_NAME, 0);

    cfg.type = BOARD_CONSOLE_TYPE;
    cfg.base = (uint32_t)BOARD_CONSOLE_BASE;
    cfg.src_freq_in_hz = clock_get_frequency(BOARD_CONSOLE_CLK_NAME);
    cfg.baudrate = BOARD_CONSOLE_BAUDRATE;

    if (status_success != console_init(&cfg))
    {
        /* failed to  initialize debug console */
        while (1)
        {
        }
    }
#else
    while (1)
    {
    }
#endif
#endif
}

// 打印时钟频率
void board_print_clock_freq(void)
{
    printf("==============================\n");
    printf(" %s clock summary\n", BOARD_NAME);
    printf("==============================\n");
    printf("cpu0:\t\t %luHz\n", clock_get_frequency(clock_cpu0));
    printf("cpu1:\t\t %luHz\n", clock_get_frequency(clock_cpu1));
    printf("axi0:\t\t %luHz\n", clock_get_frequency(clock_axi0));
    printf("axi1:\t\t %luHz\n", clock_get_frequency(clock_axi1));
    printf("axi2:\t\t %luHz\n", clock_get_frequency(clock_axi2));
    printf("ahb:\t\t %luHz\n", clock_get_frequency(clock_ahb));
    printf("mchtmr0:\t %luHz\n", clock_get_frequency(clock_mchtmr0));
    printf("mchtmr1:\t %luHz\n", clock_get_frequency(clock_mchtmr1));
    printf("xpi0:\t\t %luHz\n", clock_get_frequency(clock_xpi0));
    printf("xpi1:\t\t %luHz\n", clock_get_frequency(clock_xpi1));
    printf("femc:\t\t %luHz\n", clock_get_frequency(clock_femc));
    printf("display:\t %luHz\n", clock_get_frequency(clock_display));
    printf("cam0:\t\t %luHz\n", clock_get_frequency(clock_camera0));
    printf("cam1:\t\t %luHz\n", clock_get_frequency(clock_camera1));
    printf("jpeg:\t\t %luHz\n", clock_get_frequency(clock_jpeg));
    printf("pdma:\t\t %luHz\n", clock_get_frequency(clock_pdma));
    printf("==============================\n");
}

void board_ungate_mchtmr_at_lp_mode(void)
{
    /* Keep cpu clock on wfi, so that mchtmr irq can still work after wfi */
    sysctl_set_cpu_lp_mode(HPM_SYSCTL, BOARD_RUNNING_CORE, cpu_lp_mode_ungate_cpu_clock);
}

// 板子初始化
void board_init(void)
{
    board_init_clock();   // 初始化时钟
    board_init_console(); // 初始化控制台
    board_init_pmp();     // 初始化pmp
                          // board_print_clock_freq(); // 输出时钟频率
}

// 初始化蜂鸣器
void board_init_beep_pins(void)
{
    HPM_IOC->PAD[BEEP].FUNC_CTL = IOC_PD17_FUNC_CTL_GPIO_D_17;
    gpio_set_pin_output_with_initial(BOARD_BEEP_POART, BOARD_BEEP_INDEX, BOARD_BEEP_PIN, 0);
}

// 打开蜂鸣器
void board_beep_open(void)
{
    gpio_write_pin(BOARD_BEEP_POART, BOARD_BEEP_INDEX, BOARD_BEEP_PIN, 1);
}

// 关闭蜂鸣器
void board_beep_close(void)
{
    gpio_write_pin(BOARD_BEEP_POART, BOARD_BEEP_INDEX, BOARD_BEEP_PIN, 0);
}

// CAN初始化
void board_init_can(CAN_Type *ptr)
{
    init_can_pins(ptr);
}
// CAN时钟初始化
uint32_t board_init_can_clock(CAN_Type *ptr)
{
    uint32_t freq = 0;
    if (ptr == HPM_CAN0)
    {
        clock_set_source_divider(clock_can0, clk_src_pll1_clk1, 5);
        freq = clock_get_frequency(clock_can0);
    }
    else if (ptr == HPM_CAN1)
    {
        clock_set_source_divider(clock_can1, clk_src_pll1_clk1, 5);
        freq = clock_get_frequency(clock_can1);
    }
    else if (ptr == HPM_CAN2)
    {
        clock_set_source_divider(clock_can2, clk_src_pll1_clk1, 5);
        freq = clock_get_frequency(clock_can2);
    }
    else if (ptr == HPM_CAN3)
    {
        clock_set_source_divider(clock_can3, clk_src_pll1_clk1, 5);
        freq = clock_get_frequency(clock_can3);
    }
    else
    {
        while (1)
            ;
    }
    return freq;
}

// 初始化串口
void board_init_uart(UART_Type *ptr)
{
    /* 在打开UART的时钟之前配置UART的引脚 */
    init_uart_pins(ptr);
    board_init_uart_clock(ptr);
}

// 初始化UART对应的时钟
uint32_t board_init_uart_clock(UART_Type *ptr)
{
    uint32_t freq = 0U;
    if (ptr == HPM_UART0)
    {
        clock_set_source_divider(clock_uart0, clk_src_osc24m, 1);
        clock_add_to_group(clock_uart0, 0);
        freq = clock_get_frequency(clock_uart0);
    }
    else if (ptr == HPM_UART1)
    {
        clock_set_source_divider(clock_uart1, clk_src_osc24m, 1);
        clock_add_to_group(clock_uart1, 0);
        freq = clock_get_frequency(clock_uart1);
    }
    else if (ptr == HPM_UART2)
    {
        clock_set_source_divider(clock_uart2, clk_src_osc24m, 1);
        clock_add_to_group(clock_uart2, 0);
        freq = clock_get_frequency(clock_uart2);
    }
    else if (ptr == HPM_UART3)
    {
        clock_set_source_divider(clock_uart3, clk_src_osc24m, 1);
        clock_add_to_group(clock_uart3, 0);
        freq = clock_get_frequency(clock_uart3);
    }
    else if (ptr == HPM_UART4)
    {
        clock_set_source_divider(clock_uart4, clk_src_osc24m, 1);
        clock_add_to_group(clock_uart4, 0);
        freq = clock_get_frequency(clock_uart4);
    }
    else if (ptr == HPM_UART5)
    {
        clock_set_source_divider(clock_uart5, clk_src_osc24m, 1);
        clock_add_to_group(clock_uart5, 0);
        freq = clock_get_frequency(clock_uart5);
    }
    else
    {
        while (1)
            ;
    }
    return freq;
}

// 初始化LED为关闭
void board_init_led_pins(void)
{
    init_led_pins_as_gpio();
    gpio_set_pin_output_with_initial(BOARD_RGB_GPIO_CTRL, BOARD_RGB_GPIO_INDEX, BOARD_R_GPIO_PIN, LED_OFF);
    gpio_set_pin_output_with_initial(BOARD_RGB_GPIO_CTRL, BOARD_RGB_GPIO_INDEX, BOARD_G_GPIO_PIN, LED_OFF);
    gpio_set_pin_output_with_initial(BOARD_RGB_GPIO_CTRL, BOARD_RGB_GPIO_INDEX, BOARD_B_GPIO_PIN, LED_OFF);
}
// 对红色灯写状态
void board_write_led_r(uint8_t state)
{
    gpio_write_pin(BOARD_RGB_GPIO_CTRL, BOARD_RGB_GPIO_INDEX, BOARD_R_GPIO_PIN, state);
}
// 对绿色灯写状态
void board_write_led_g(uint8_t state)
{
    gpio_write_pin(BOARD_RGB_GPIO_CTRL, BOARD_RGB_GPIO_INDEX, BOARD_G_GPIO_PIN, state);
}
// 对蓝色灯写状态
void board_write_led_b(uint8_t state)
{
    gpio_write_pin(BOARD_RGB_GPIO_CTRL, BOARD_RGB_GPIO_INDEX, BOARD_B_GPIO_PIN, state);
}

// 毫秒延时
void board_delay_ms(uint32_t ms)
{
    clock_cpu_delay_ms(ms);
}

// 微秒延时
void board_delay_us(uint32_t us)
{
    clock_cpu_delay_us(us);
}

uint32_t board_init_femc_clock(void)
{
    clock_set_source_divider(clock_femc, clk_src_pll2_clk0, 2U); /* 166Mhz */
    return clock_get_frequency(clock_femc);
}

void board_init_i2c(I2C_Type *ptr)
{
    hpm_stat_t stat;
    uint32_t freq;
    i2c_config_t config;
    init_i2c_pins(ptr);
    config.i2c_mode = i2c_mode_normal;
    config.is_10bit_addressing = false;
    if (ptr == BOARD_I2C1)
    {
        clock_add_to_group(BOARD_I2C1_CLK, 0);
        clock_set_source_divider(BOARD_I2C1_CLK, clk_src_osc24m, 1U);
        freq = clock_get_frequency(BOARD_I2C1_CLK);
    }
    else if (ptr == BOARD_I2C2)
    {
        clock_add_to_group(BOARD_I2C2_CLK, 0);
        clock_set_source_divider(BOARD_I2C2_CLK, clk_src_osc24m, 1U);
        freq = clock_get_frequency(BOARD_I2C2_CLK);
    }
    stat = i2c_init_master(ptr, freq, &config);
    if (stat != status_success)
    {
        printf("failed to initialize i2c 0x%lx\n", (uint32_t)ptr);
        while (1)
        {
        }
    }
}

uint32_t board_init_spi_clock(SPI_Type *ptr)
{
    if (ptr == HPM_SPI2)
    {
        /* SPI2 clock configure */
        clock_add_to_group(clock_spi2, 0);
        clock_set_source_divider(clock_spi2, clk_src_pll1_clk1, 5U); /* 80MHz */

        return clock_get_frequency(clock_spi2);
    }
    else
    {
        return 0;
    }
}

void board_init_spi_pins(SPI_Type *ptr)
{
    init_spi_pins(ptr);
}

void board_init_usb_pins(void)
{
    /* set pull-up for USBx OC pin and ID pin */
    init_usb_pins(HPM_USB0);
    /* configure USBx ID pin as input function */
    gpio_set_pin_input(BOARD_USB0_ID_PORT, BOARD_USB0_ID_GPIO_INDEX, BOARD_USB0_ID_GPIO_PIN);
    /* configure USBx OC Flag pin as input function */
    gpio_set_pin_input(BOARD_USB0_OC_PORT, BOARD_USB0_OC_GPIO_INDEX, BOARD_USB0_OC_GPIO_PIN);

    /* set pull-up for USBx OC pin and ID pin */
    init_usb_pins(HPM_USB1);
    /* configure USBx ID pin as input function */
    gpio_set_pin_input(BOARD_USB1_ID_PORT, BOARD_USB1_ID_GPIO_INDEX, BOARD_USB1_ID_GPIO_PIN);
    /* configure USBx OC Flag pin as input function */
    gpio_set_pin_input(BOARD_USB1_OC_PORT, BOARD_USB1_OC_GPIO_INDEX, BOARD_USB1_OC_GPIO_PIN);
}

void board_init_pmp(void)
{
    uint32_t start_addr;
    uint32_t end_addr;
    uint32_t length;
    pmp_entry_t pmp_entry[16];
    uint8_t index = 0;

    /* Init noncachable memory */
    extern uint32_t __noncacheable_start__[];
    extern uint32_t __noncacheable_end__[];
    start_addr = (uint32_t)__noncacheable_start__;
    end_addr = (uint32_t)__noncacheable_end__;
    length = end_addr - start_addr;
    if (length > 0)
    {
        /* Ensure the address and the length are power of 2 aligned */
        assert((length & (length - 1U)) == 0U);
        assert((start_addr & (length - 1U)) == 0U);
        pmp_entry[index].pmp_addr = PMP_NAPOT_ADDR(start_addr, length);
        pmp_entry[index].pmp_cfg.val = PMP_CFG(READ_EN, WRITE_EN, EXECUTE_EN, ADDR_MATCH_NAPOT, REG_UNLOCK);
        pmp_entry[index].pma_addr = PMA_NAPOT_ADDR(start_addr, length);
        pmp_entry[index].pma_cfg.val = PMA_CFG(ADDR_MATCH_NAPOT, MEM_TYPE_MEM_NON_CACHE_BUF, AMO_EN);
        index++;
    }

    /* Init share memory */
    extern uint32_t __share_mem_start__[];
    extern uint32_t __share_mem_end__[];
    start_addr = (uint32_t)__share_mem_start__;
    end_addr = (uint32_t)__share_mem_end__;
    length = end_addr - start_addr;
    if (length > 0)
    {
        /* Ensure the address and the length are power of 2 aligned */
        assert((length & (length - 1U)) == 0U);
        assert((start_addr & (length - 1U)) == 0U);
        pmp_entry[index].pmp_addr = PMP_NAPOT_ADDR(start_addr, length);
        pmp_entry[index].pmp_cfg.val = PMP_CFG(READ_EN, WRITE_EN, EXECUTE_EN, ADDR_MATCH_NAPOT, REG_UNLOCK);
        pmp_entry[index].pma_addr = PMA_NAPOT_ADDR(start_addr, length);
        pmp_entry[index].pma_cfg.val = PMA_CFG(ADDR_MATCH_NAPOT, MEM_TYPE_MEM_NON_CACHE_BUF, AMO_EN);
        index++;
    }
    pmp_config(&pmp_entry[0], index);
}

void board_init_clock(void)
{
    uint32_t cpu0_freq = clock_get_frequency(clock_cpu0);
    if (cpu0_freq == PLLCTL_SOC_PLL_REFCLK_FREQ)
    {
        /* Configure the External OSC ramp-up time: ~9ms */
        pllctl_xtal_set_rampup_time(HPM_PLLCTL, 32UL * 1000UL * 9U);

        /* Select clock setting preset1 */
        sysctl_clock_set_preset(HPM_SYSCTL, sysctl_preset_1);
    }

    /* Add most Clocks to group 0 */
    /* not open uart clock in this API, uart should configure pin function before opening clock */
    clock_add_to_group(clock_cpu0, 0);
    clock_add_to_group(clock_mchtmr0, 0);
    clock_add_to_group(clock_axi0, 0);
    clock_add_to_group(clock_axi1, 0);
    clock_add_to_group(clock_axi2, 0);
    clock_add_to_group(clock_ahb, 0);
    clock_add_to_group(clock_femc, 0);
    clock_add_to_group(clock_xpi0, 0);
    clock_add_to_group(clock_xpi1, 0);
    clock_add_to_group(clock_gptmr0, 0);
    clock_add_to_group(clock_gptmr1, 0);
    clock_add_to_group(clock_gptmr2, 0);
    clock_add_to_group(clock_gptmr3, 0);
    clock_add_to_group(clock_gptmr4, 0);
    clock_add_to_group(clock_gptmr5, 0);
    clock_add_to_group(clock_gptmr6, 0);
    clock_add_to_group(clock_gptmr7, 0);
    clock_add_to_group(clock_i2c0, 0);
    clock_add_to_group(clock_i2c1, 0);
    clock_add_to_group(clock_i2c2, 0);
    clock_add_to_group(clock_i2c3, 0);
    clock_add_to_group(clock_spi0, 0);
    clock_add_to_group(clock_spi1, 0);
    clock_add_to_group(clock_spi2, 0);
    clock_add_to_group(clock_spi3, 0);
    clock_add_to_group(clock_can0, 0);
    clock_add_to_group(clock_can1, 0);
    clock_add_to_group(clock_can2, 0);
    clock_add_to_group(clock_can3, 0);
    clock_add_to_group(clock_display, 0);
    clock_add_to_group(clock_sdxc0, 0);
    clock_add_to_group(clock_sdxc1, 0);
    clock_add_to_group(clock_camera0, 0);
    clock_add_to_group(clock_camera1, 0);
    clock_add_to_group(clock_ptpc, 0);
    clock_add_to_group(clock_ref0, 0);
    clock_add_to_group(clock_ref1, 0);
    clock_add_to_group(clock_watchdog0, 0);
    clock_add_to_group(clock_eth0, 0);
    clock_add_to_group(clock_eth1, 0);
    clock_add_to_group(clock_sdp, 0);
    clock_add_to_group(clock_xdma, 0);
    clock_add_to_group(clock_ram0, 0);
    clock_add_to_group(clock_ram1, 0);
    clock_add_to_group(clock_usb0, 0);
    clock_add_to_group(clock_usb1, 0);
    clock_add_to_group(clock_jpeg, 0);
    clock_add_to_group(clock_pdma, 0);
    clock_add_to_group(clock_kman, 0);
    clock_add_to_group(clock_gpio, 0);
    clock_add_to_group(clock_mbx0, 0);
    clock_add_to_group(clock_hdma, 0);
    clock_add_to_group(clock_rng, 0);
    clock_add_to_group(clock_mot0, 0);
    clock_add_to_group(clock_mot1, 0);
    clock_add_to_group(clock_mot2, 0);
    clock_add_to_group(clock_mot3, 0);
    clock_add_to_group(clock_acmp, 0);
    clock_add_to_group(clock_dao, 0);
    clock_add_to_group(clock_msyn, 0);
    clock_add_to_group(clock_lmm0, 0);
    clock_add_to_group(clock_lmm1, 0);
    clock_add_to_group(clock_pdm, 0);

    clock_add_to_group(clock_adc0, 0);
    clock_add_to_group(clock_adc1, 0);
    clock_add_to_group(clock_adc2, 0);
    clock_add_to_group(clock_adc3, 0);

    clock_add_to_group(clock_i2s0, 0);
    clock_add_to_group(clock_i2s1, 0);
    clock_add_to_group(clock_i2s2, 0);
    clock_add_to_group(clock_i2s3, 0);
    /* Connect Group0 to CPU0 */
    clock_connect_group_to_cpu(0, 0);

    /* Add the CPU1 clock to Group1 */
    clock_add_to_group(clock_mchtmr1, 1);
    clock_add_to_group(clock_mbx1, 1);
    /* Connect Group1 to CPU1 */
    clock_connect_group_to_cpu(1, 1);

    /* Bump up DCDC voltage to 1200mv */
    pcfg_dcdc_set_voltage(HPM_PCFG, 1200);

    if (status_success != pllctl_init_int_pll_with_freq(HPM_PLLCTL, 0, BOARD_CPU_FREQ))
    {
        printf("Failed to set pll0_clk0 to %ldHz\n", BOARD_CPU_FREQ);
        while (1)
        {
        }
    }

    clock_set_source_divider(clock_cpu0, clk_src_pll0_clk0, 1);
    clock_set_source_divider(clock_cpu1, clk_src_pll0_clk0, 1);
    clock_update_core_clock();

    clock_set_source_divider(clock_ahb, clk_src_pll1_clk1, 2); /*200m hz*/

    clock_set_source_divider(clock_aud1, clk_src_pll3_clk0, 54); /* config clock_aud1 for 44100*n sample rate */
    clock_set_source_divider(clock_mchtmr0, clk_src_osc24m, 1);
    clock_set_source_divider(clock_mchtmr1, clk_src_osc24m, 1);
}

// 找不到地方放就放在这里了 dowdow

// dma接收触发函数
hpm_stat_t uart_rx_trigger_dma(DMA_Type *dma_ptr, uint8_t ch_num, UART_Type *uart_ptr, uint32_t dst, uint32_t size)
{
    dma_handshake_config_t config;
    dma_default_handshake_config(dma_ptr, &config);
    config.ch_index = ch_num;
    config.dst = dst;
    config.dst_fixed = false;
    config.src = (uint32_t)&uart_ptr->RBR;
    config.src_fixed = true;
    config.data_width = DMA_TRANSFER_WIDTH_BYTE;
    config.size_in_byte = size;
    return dma_setup_handshake(dma_ptr, &config, true);
}

// dma发送触发函数
hpm_stat_t uart_tx_trigger_dma(DMA_Type *dma_ptr, uint8_t ch_num, UART_Type *uart_ptr, uint32_t src, uint32_t size)
{
    dma_handshake_config_t config;
    dma_default_handshake_config(dma_ptr, &config);
    config.ch_index = ch_num;
    config.dst = (uint32_t)&uart_ptr->THR;
    config.dst_fixed = true;
    config.src = src;
    config.src_fixed = false;
    config.data_width = DMA_TRANSFER_WIDTH_BYTE;
    config.size_in_byte = size;
    return dma_setup_handshake(dma_ptr, &config, true);
}
